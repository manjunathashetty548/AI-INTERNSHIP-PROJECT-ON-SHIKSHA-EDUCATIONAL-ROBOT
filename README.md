"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                        SHIKSHA ROBOT PROJECT                             â•‘
â•‘              AI-Integrated Educational Assistant System                  â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“‹ PROJECT OVERVIEW
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
SHIKSHA Robot is an innovative educational bot developed at Experimind Labs
to support experiential STEM learning in resource-constrained classrooms.
Designed as an interactive teaching assistant, it uses barcode scanning to
detect educational charts and narrates stories or lessons aloud, making
learning engaging and accessible for students.

ğŸ¯ OBJECTIVES
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- Develop affordable, scalable educational robot for government schools
- Enable interactive learning through voice narration and visual engagement
- Use barcode-based chart recognition to trigger relevant educational content
- Build durable, modular design for long-term classroom use
- Minimize production costs without compromising functionality

ğŸ” SCOPE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- Target Audience: Government schools and budget-constrained institutions
- Application: Interactive teaching assistant for STEM education
- Scalability: Designed for mass production (8 units deployed)
- Technology: Robotics + AI + Embedded Systems + Educational Content
- Social Impact: Making technology-driven education accessible to all

ğŸ¢ ABOUT EXPERIMIND LABS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- EdTech startup innovating in experiential STEM education
- Products: Shiksha Robot, Anubhav Kit, Prasthuti Platform, P-STEM Labs
- Focus: Bridging theoretical learning with hands-on application
- Mission: Multilingual, accessible learning for diverse schools

ğŸ¤– KEY FEATURES
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- Barcode-based chart detection (98.5% accuracy)
- Pre-loaded educational content narration
- NeoPixel LED facial expressions (64 LEDs)
- Servo-controlled ear movements for engagement
- Durable chassis (MDF, SS Steel, MS Steel)
- Buck converter power management system
- 6-8 hours battery life
- Response time < 0.5 seconds

ğŸ”§ HARDWARE COMPONENTS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Microcontroller  : Raspberry Pi 4
Scanner          : Barcode Scanner Module (Serial)
Display          : NeoPixel LED Matrix (64 pixels)
Motors           : 2x SG90 Servo Motors
Audio            : Amplifier Module + 5W Speaker
Power            : 12V Battery + Buck Converter
Chassis          : MDF Board, SS Steel, MS Steel

ğŸ’» SOFTWARE STACK
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- Python 3.x (Primary language)
- RPi.GPIO (Servo control)
- Adafruit NeoPixel (LED control)
- PyGame (Audio playback)
- PySerial (Barcode scanner interface)
- SMBus (Power monitoring)

âš™ï¸ HOW IT WORKS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Chart Detection:
   â€¢ Teacher places educational chart in front of robot
   â€¢ Barcode scanner reads unique chart identifier
   â€¢ System validates barcode and prepares content

2. Content Delivery:
   â€¢ Robot displays "thinking" expression (blue eyes)
   â€¢ Audio module loads corresponding lesson file
   â€¢ Robot shows "excited" expression and wiggles ears

3. Narration:
   â€¢ Pre-recorded educational content plays through speaker
   â€¢ Robot displays "listening" expression
   â€¢ Students engage with interactive visual feedback

4. Completion:
   â€¢ Content finishes playing
   â€¢ Robot returns to "happy" expression
   â€¢ Ready for next chart scan

ğŸ“Š DEVELOPMENT PHASES
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Phase 1: System Architecture Planning
  â€¢ Component selection (MCU, sensors, modules)
  â€¢ Workflow breakdown (Hardware | Firmware | Assembly)

Phase 2: PCB Design
  â€¢ Tools: EasyEDA / KiCad
  â€¢ Schematics, layout design, trace routing
  â€¢ Board fabrication and testing

Phase 3: Mechanical Fabrication
  â€¢ Materials: MDF Board, SS Steel, MS Steel
  â€¢ Laser cutting, 3D printing, mounting assembly

ğŸ”¬ TESTING & DEBUGGING
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Functional Testing:
  âœ“ Raspberry Pi boot verification
  âœ“ Speaker clarity and audio quality
  âœ“ Chart mode operation validation

Electrical Testing:
  âœ“ Voltage level verification
  âœ“ Short circuit prevention
  âœ“ Stable power delivery

Challenges Solved:
  âœ“ Audio distortion â†’ Adjusted amplifier gain
  âœ“ Barcode accuracy â†’ Calibrated sensor distance/angle
  âœ“ Power balancing â†’ Buck converter with heat sink
  âœ“ Sensor noise â†’ Software filters + mounting isolation
  âœ“ Mechanical fitting â†’ CAD reworks for tolerances

ğŸ“ˆ PROJECT ACHIEVEMENTS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ“ Successfully built and deployed 8 Shiksha Robots
âœ“ Maintained affordability while ensuring functionality
âœ“ 98.5% barcode detection accuracy
âœ“ <0.5s average response time
âœ“ 6-8 hours continuous battery life
âœ“ Scalable design for mass production

ğŸš€ FUTURE SCOPE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- Voice command recognition and natural language interaction
- Multilingual content support for diverse classrooms
- Cloud connectivity for remote content updates
- Mobile app integration for teacher control
- Advanced AI for personalized learning paths
- Gesture recognition capabilities
- Real-time analytics and progress tracking

ğŸ“ KEY LEARNINGS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- Complete product development cycle (concept â†’ deployment)
- Embedded systems design and hardware integration
- Real-time sensor interfacing and control
- Circuit design and PCB fabrication
- Cross-domain synchronization in robotic systems
- Power management and optimization techniques
- Team collaboration and project management
- Developing scalable, socially impactful technology

ğŸ“¦ INSTALLATION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Create project directory
mkdir shiksha-robot && cd shiksha-robot

# Create audio directory
mkdir audio_files

# Install dependencies
pip3 install RPi.GPIO adafruit-circuitpython-neopixel pygame pyserial smbus2

# Save this code as shiksha_robot.py and run
python3 shiksha_robot.py

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  "Empowering education through robotics â€“ Making learning interactive,   â•‘
â•‘   accessible, and engaging for every student."                           â•‘
â•‘                                                                          â•‘
â•‘  Developed at Experimind Labs                                            â•‘
â•‘  Team Size: 7 | Mentor: Mr. Adarsh Guruprasad Devadiga (CTO)           â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""

import serial
import time
import board
import neopixel
import RPi.GPIO as GPIO
import pygame
import os
from threading import Thread
import smbus

# ============================================================================
# SYSTEM ARCHITECTURE DIAGRAM
# ============================================================================
"""
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     SHIKSHA ROBOT SYSTEM ARCHITECTURE                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚      â”‚   Barcode    â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚  Raspberry   â”‚              â”‚
â”‚      â”‚   Scanner    â”‚   Serial UART      â”‚     Pi 4     â”‚              â”‚
â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚                                                 â”‚                       â”‚
â”‚      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                          â”‚        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚      â”‚   NeoPixel   â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”‚   Servo    â”‚ â”‚
â”‚      â”‚   64 LEDs    â”‚   GPIO Control           â”‚        â”‚   Motors   â”‚ â”‚
â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â”‚        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                 â”‚                       â”‚
â”‚      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                          â”‚        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚      â”‚    Audio     â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”‚   Power    â”‚ â”‚
â”‚      â”‚   Module     â”‚   PWM Audio              â”‚        â”‚ Management â”‚ â”‚
â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â”‚        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                         â”‚
â”‚  Data Flow: Barcode â†’ Processing â†’ Audio + Visual + Motion Response    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
"""

# ============================================================================
# CONFIGURATION SETTINGS
# ============================================================================

CONFIG = {
    "barcode_scanner": {
        "port": "/dev/ttyUSB0",
        "baudrate": 9600
    },
    "neopixel": {
        "pin": board.D18,
        "num_pixels": 64,
        "brightness": 0.5
    },
    "servo": {
        "left_pin": 17,
        "right_pin": 27
    },
    "audio": {
        "directory": "audio_files",
        "volume": 0.8
    },
    "power": {
        "i2c_address": 0x48,
        "low_battery_threshold": 20
    }
}

# ============================================================================
# BARCODE SCANNER MODULE
# ============================================================================

class BarcodeScanner:
    """
    Barcode Scanner Module
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Handles barcode scanning for educational chart detection.
    Uses serial communication to read barcode data.
    
    Technical Specifications:
    â€¢ Interface: Serial UART
    â€¢ Baudrate: 9600 bps
    â€¢ Protocol: ASCII text output
    â€¢ Scan Rate: Up to 300 scans/second
    """
    
    def __init__(self, port='/dev/ttyUSB0', baudrate=9600):
        try:
            self.serial_port = serial.Serial(port, baudrate, timeout=1)
            print(f"âœ“ Barcode Scanner initialized on {port}")
        except Exception as e:
            print(f"âœ— Barcode Scanner initialization failed: {e}")
            self.serial_port = None
        
    def read_barcode(self):
        """Read barcode data from scanner."""
        if self.serial_port and self.serial_port.in_waiting > 0:
            try:
                barcode_data = self.serial_port.readline().decode('utf-8').strip()
                return barcode_data
            except Exception as e:
                print(f"Error reading barcode: {e}")
                return None
        return None
    
    def close(self):
        """Close serial connection."""
        if self.serial_port:
            self.serial_port.close()
            print("âœ“ Barcode Scanner closed")


# ============================================================================
# NEOPIXEL LED FACIAL EXPRESSION MODULE
# ============================================================================

class FacialExpression:
    """
    NeoPixel LED Facial Expression Module
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Controls 64 NeoPixel LED matrix for displaying facial expressions.
    Creates engaging visual feedback for student interaction.
    
    Expression Types:
    â€¢ Happy Face: Green eyes + Yellow smile
    â€¢ Thinking Face: Blue eyes + Neutral mouth
    â€¢ Excited Face: Cyan wide eyes + Big yellow smile
    â€¢ Listening Face: Green attentive eyes + Small smile
    
    Technical Specifications:
    â€¢ LEDs: 64 WS2812B NeoPixels
    â€¢ Control: Single GPIO data line
    â€¢ Update Rate: 400 KHz
    â€¢ Color Depth: 24-bit RGB (16.7M colors)
    """
    
    def __init__(self, pin=board.D18, num_pixels=64, brightness=0.5):
        try:
            self.pixels = neopixel.NeoPixel(
                pin, 
                num_pixels, 
                brightness=brightness,
                auto_write=False
            )
            print(f"âœ“ NeoPixel LEDs initialized ({num_pixels} pixels)")
        except Exception as e:
            print(f"âœ— NeoPixel initialization failed: {e}")
            self.pixels = None
        
    def happy_face(self):
        """Display happy expression - Default welcoming state"""
        if not self.pixels:
            return
            
        self.pixels.fill((0, 0, 0))
        
        # Eyes (green - welcoming)
        eye_positions = [18, 19, 21, 22, 42, 43, 45, 46]
        for pos in eye_positions:
            self.pixels[pos] = (0, 255, 0)
        
        # Smile (yellow - friendly)
        smile_positions = [49, 50, 51, 52, 53, 54, 48, 55]
        for pos in smile_positions:
            self.pixels[pos] = (255, 255, 0)
            
        self.pixels.show()
    
    def thinking_face(self):
        """Display thinking expression - Processing state"""
        if not self.pixels:
            return
            
        self.pixels.fill((0, 0, 0))
        
        # Eyes (blue - contemplative)
        eye_positions = [18, 19, 21, 22, 42, 43, 45, 46]
        for pos in eye_positions:
            self.pixels[pos] = (0, 0, 255)
        
        # Neutral mouth
        mouth_positions = [50, 51, 52, 53]
        for pos in mouth_positions:
            self.pixels[pos] = (100, 100, 100)
            
        self.pixels.show()
    
    def excited_face(self):
        """Display excited expression - Engaging moments"""
        if not self.pixels:
            return
            
        self.pixels.fill((0, 0, 0))
        
        # Wide eyes (cyan - excited)
        eye_positions = [17, 18, 19, 20, 21, 22, 41, 42, 43, 44, 45, 46]
        for pos in eye_positions:
            self.pixels[pos] = (0, 255, 255)
        
        # Big smile (bright yellow)
        smile_positions = [48, 49, 50, 51, 52, 53, 54, 55, 40, 47]
        for pos in smile_positions:
            self.pixels[pos] = (255, 200, 0)
            
        self.pixels.show()
    
    def listening_face(self):
        """Display listening expression - During narration"""
        if not self.pixels:
            return
            
        self.pixels.fill((0, 0, 0))
        
        # Attentive eyes (green)
        eye_positions = [18, 19, 21, 22, 42, 43, 45, 46]
        for pos in eye_positions:
            self.pixels[pos] = (0, 200, 100)
        
        # Small smile
        smile_positions = [50, 51, 52, 53]
        for pos in smile_positions:
            self.pixels[pos] = (150, 150, 0)
            
        self.pixels.show()
    
    def clear(self):
        """Clear all LEDs"""
        if self.pixels:
            self.pixels.fill((0, 0, 0))
            self.pixels.show()


# ============================================================================
# SERVO MOTOR CONTROL MODULE
# ============================================================================

class ServoController:
    """
    Servo Motor Control Module
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Controls two SG90 servo motors for robotic ear movements.
    Adds physical expressiveness to enhance student engagement.
    
    Movement Types:
    â€¢ Wiggle: Alternating ear movements for attention
    â€¢ Perk Up: Both ears raised - attention mode
    â€¢ Neutral: Centered position - default state
    
    Technical Specifications:
    â€¢ Motors: 2x SG90 Servo Motors
    â€¢ Operating Voltage: 4.8V - 6V
    â€¢ Rotation: 0Â° to 180Â°
    â€¢ Control Signal: PWM (50 Hz)
    â€¢ Torque: 1.8 kgâ‹…cm (at 4.8V)
    """
    
    def __init__(self, left_pin=17, right_pin=27):
        try:
            GPIO.setmode(GPIO.BCM)
            GPIO.setup(left_pin, GPIO.OUT)
            GPIO.setup(right_pin, GPIO.OUT)
            
            self.left_servo = GPIO.PWM(left_pin, 50)  # 50Hz PWM
            self.right_servo = GPIO.PWM(right_pin, 50)
            
            self.left_servo.start(0)
            self.right_servo.start(0)
            print(f"âœ“ Servo motors initialized")
        except Exception as e:
            print(f"âœ— Servo initialization failed: {e}")
            self.left_servo = None
            self.right_servo = None
    
    def set_angle(self, servo, angle):
        """Set servo angle (0-180 degrees)"""
        if not servo:
            return
            
        duty_cycle = 2 + (angle / 18)
        servo.ChangeDutyCycle(duty_cycle)
        time.sleep(0.3)
        servo.ChangeDutyCycle(0)
    
    def wiggle_ears(self, times=3):
        """Wiggle both ears for attention"""
        if not self.left_servo or not self.right_servo:
            return
            
        for _ in range(times):
            self.set_angle(self.left_servo, 45)
            self.set_angle(self.right_servo, 135)
            time.sleep(0.2)
            self.set_angle(self.left_servo, 135)
            self.set_angle(self.right_servo, 45)
            time.sleep(0.2)
    
    def perk_up(self):
        """Perk ears up - attention mode"""
        if not self.left_servo or not self.right_servo:
            return
            
        self.set_angle(self.left_servo, 45)
        self.set_angle(self.right_servo, 45)
    
    def neutral_position(self):
        """Return ears to neutral position"""
        if not self.left_servo or not self.right_servo:
            return
            
        self.set_angle(self.left_servo, 90)
        self.set_angle(self.right_servo, 90)
    
    def cleanup(self):
        """Cleanup GPIO resources"""
        if self.left_servo:
            self.left_servo.stop()
        if self.right_servo:
            self.right_servo.stop()
        GPIO.cleanup()


# ============================================================================
# AUDIO PLAYBACK SYSTEM
# ============================================================================

class AudioPlayer:
    """
    Audio Playback System
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Manages educational content narration through audio playback.
    Plays pre-recorded lessons based on scanned chart barcodes.
    
    Audio Format Support:
    â€¢ MP3: Compressed audio (recommended)
    â€¢ WAV: Uncompressed high-quality audio
    
    Technical Specifications:
    â€¢ Sample Rate: 44.1 kHz
    â€¢ Bit Depth: 16-bit
    â€¢ Channels: Stereo/Mono
    â€¢ Output: 5W Speaker via Amplifier
    â€¢ File Naming: <BARCODE>.mp3 (e.g., CHART001.mp3)
    """
    
    def __init__(self, audio_directory="audio_files", volume=0.8):
        try:
            pygame.mixer.init()
            pygame.mixer.music.set_volume(volume)
            self.audio_dir = audio_directory
            self.audio_files = self._load_audio_files()
            print(f"âœ“ Audio Player initialized ({len(self.audio_files)} files loaded)")
        except Exception as e:
            print(f"âœ— Audio Player initialization failed: {e}")
            self.audio_files = {}
    
    def _load_audio_files(self):
        """Load all audio files from directory"""
        audio_dict = {}
        if os.path.exists(self.audio_dir):
            for file in os.listdir(self.audio_dir):
                if file.endswith(('.mp3', '.wav')):
                    barcode = file.split('.')[0]
                    audio_dict[barcode] = os.path.join(self.audio_dir, file)
                    print(f"  â””â”€ {barcode} â†’ {file}")
        else:
            print(f"  â””â”€ Audio directory not found. Create: mkdir {self.audio_dir}")
        return audio_dict
    
    def play_audio(self, barcode):
        """Play audio corresponding to barcode"""
        if barcode in self.audio_files:
            try:
                pygame.mixer.music.load(self.audio_files[barcode])
                pygame.mixer.music.play()
                print(f"ğŸ”Š Playing: {barcode}")
                return True
            except Exception as e:
                print(f"Error playing audio: {e}")
                return False
        else:
            print(f"âš  No audio for: {barcode}")
            return False
    
    def stop_audio(self):
        """Stop current audio playback"""
        pygame.mixer.music.stop()
    
    def is_playing(self):
        """Check if audio is currently playing"""
        return pygame.mixer.music.get_busy()


# ============================================================================
# POWER MANAGEMENT SYSTEM
# ============================================================================

class PowerManager:
    """
    Power Management System
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Monitors battery voltage, current draw, and system power consumption.
    Provides alerts for low battery conditions.
    
    Technical Specifications:
    â€¢ Sensor: INA219 Current/Voltage Monitor
    â€¢ Interface: I2C
    â€¢ Battery: 12V Lithium-ion/Lead-acid
    â€¢ Converter: Buck Converter (12V â†’ 5V, 3A)
    â€¢ Protection: Over-voltage, under-voltage, short-circuit
    â€¢ Battery Life: 6-8 hours continuous operation
    """
    
    def __init__(self, i2c_address=0x48):
        try:
            self.bus = smbus.SMBus(1)
            self.address = i2c_address
            print(f"âœ“ Power Manager initialized")
        except Exception as e:
            print(f"âœ— Power Manager initialization failed: {e}")
            self.bus = None
        
    def read_voltage(self):
        """Read current battery voltage"""
        if not self.bus:
            return 12.0  # Default value for simulation
            
        try:
            data = self.bus.read_i2c_block_data(self.address, 0x02, 2)
            voltage = (data[0] << 8 | data[1]) * 0.004
            return voltage
        except:
            return 12.0
    
    def check_battery_status(self):
        """Check comprehensive battery status"""
        voltage = self.read_voltage()
        
        # 12V battery range
        min_voltage = 11.0  # 0%
        max_voltage = 12.6  # 100%
        
        percentage = ((voltage - min_voltage) / (max_voltage - min_voltage)) * 100
        percentage = max(0, min(100, percentage))
        
        if percentage > 50:
            status = "Good"
        elif percentage > 20:
            status = "Fair"
        else:
            status = "Low Battery"
        
        return {
            'voltage': voltage,
            'percentage': percentage,
            'status': status
        }


# ============================================================================
# MAIN SHIKSHA ROBOT INTEGRATION SYSTEM
# ============================================================================

class ShikshaRobot:
    """
    SHIKSHA Robot Main Integration System
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    Complete system integration coordinating all subsystems:
    â€¢ Barcode scanning and chart recognition
    â€¢ LED facial expressions for emotional engagement
    â€¢ Servo motor ear movements for physical interaction
    â€¢ Audio playback for educational content delivery
    â€¢ Power monitoring for system health
    
    Workflow:
    1. Idle State: Robot displays happy face, awaiting input
    2. Chart Detection: Barcode scanner reads chart identifier
    3. Processing: System validates barcode and loads content
    4. Content Delivery: Audio plays with synchronized animations
    5. Return to Idle: Robot ready for next interaction
    
    Performance Metrics:
    â€¢ Detection Accuracy: 98.5%
    â€¢ Response Time: < 0.5 seconds
    â€¢ Uptime: 6-8 hours per charge
    â€¢ Concurrent Operations: Audio + LED + Servo control
    """
    
    def __init__(self):
        print("\n" + "="*70)
        print("  SHIKSHA ROBOT - AI-Integrated Educational Assistant")
        print("  Developed at Experimind Labs")
        print("="*70 + "\n")
        
        print("Initializing Robot Subsystems...\n")
        
        self.scanner = BarcodeScanner(
            CONFIG['barcode_scanner']['port'],
            CONFIG['barcode_scanner']['baudrate']
        )
        
        self.face = FacialExpression(
            CONFIG['neopixel']['pin'],
            CONFIG['neopixel']['num_pixels'],
            CONFIG['neopixel']['brightness']
        )
        
        self.servo = ServoController(
            CONFIG['servo']['left_pin'],
            CONFIG['servo']['right_pin']
        )
        
        self.audio = AudioPlayer(
            CONFIG['audio']['directory'],
            CONFIG['audio']['volume']
        )
        
        self.power = PowerManager(CONFIG['power']['i2c_address'])
        
        self.current_state = "idle"
        self.last_barcode = None
        self.running = False
        
        print("\n" + "="*70)
        print("âœ“ ALL SYSTEMS INITIALIZED SUCCESSFULLY")
        print("="*70 + "\n")
    
    def start(self):
        """Start the robot system and enter main control loop"""
        self.running = True
        print("ğŸš€ SHIKSHA ROBOT STARTED\n")
        print("System Status: OPERATIONAL")
        print("Mode: Interactive Learning Assistant")
        print("Waiting for chart detection...\n")
        
        self.welcome_sequence()
        
        try:
            while self.running:
                self.main_loop()
                time.sleep(0.1)
        except KeyboardInterrupt:
            print("\n\nâš  Shutdown signal received...")
            self.shutdown()
    
    def welcome_sequence(self):
        """Display welcome animation on startup"""
        print("â–¶ Playing welcome sequence...")
        self.face.excited_face()
        self.servo.wiggle_ears(2)
        time.sleep(1)
        self.face.happy_face()
        self.servo.neutral_position()
        print("âœ“ Ready for interaction\n")
    
    def main_loop(self):
        """
        Main robot control loop
        Handles chart detection and orchestrates response
        """
        # Periodic battery status check (every 60 seconds)
        if int(time.time()) % 60 == 0:
            self.check_power_status()
        
        # Check for barcode input
        barcode = self.scanner.read_barcode()
        
        if barcode and barcode != self.last_barcode and not self.audio.is_playing():
            print(f"\n{'='*70}")
            print(f"ğŸ“Š CHART DETECTED: {barcode}")
            print(f"{'='*70}")
            self.process_chart(barcode)
            self.last_barcode = barcode
    
    def process_chart(self, barcode):
        """
        Process detected chart and deliver educational content
        
        Workflow:
        1. Show processing state (thinking face + perked ears)
        2. Load and play audio content
        3. Display engaged animations
        4. Monitor playback completion
        5. Return to ready state
        """
        print(f"â–¶ Processing chart: {barcode}")
        
        # Processing state
        self.face.thinking_face()
        self.servo.perk_up()
        time.sleep(0.5)
        
        # Attempt content delivery
        if self.audio.play_audio(barcode):
            # Engaged state
            self.face.excited_face()
            self.servo.wiggle_ears(1)
            time.sleep(0.5)
            self.face.listening_face()
            
            # Monitor playback
            print("  â””â”€ Content delivery in progress...")
            while self.audio.is_playing():
                time.sleep(0.5)
            
            # Completion
            print("  â””â”€ âœ“ Content delivered successfully")
            print(f"{'='*70}\n")
            self.face.happy_face()
            self.servo.neutral_position()
            time.sleep(1)
            
        else:
            # Error state
            print("  â””â”€ âœ— Content not available")
            print(f"{'='*70}\n")
            self.face.clear()
            time.sleep(0.5)
            self.face.happy_face()
            self.servo.neutral_position()
    
    def check_power_status(self):
        """Monitor and display battery status"""
        status = self.power.check_battery_status()
        print(f"\nğŸ”‹ Battery: {status['percentage']:.1f}% "
              f"({status['voltage']:.2f}V) - {status['status']}\n")
        
        if status['percentage'] < CONFIG['power']['low_battery_threshold']:
            print("  âš  WARNING: Low battery detected! Please recharge soon.\n")
    
    def shutdown(self):
        """
        Gracefully shutdown robot system
        Cleanup all hardware resources
        """
        print("\n" + "="*70)
        print("INITIATING SHUTDOWN SEQUENCE")
        print("="*70 + "\n")
        
        self.running = False
        
        print("Stopping audio playback...")
        self.audio.stop_audio()
        
        print("Clearing LED display...")
        self.face.clear()
        
        print("Resetting servo positions...")
        self.servo.neutral_position()
        time.sleep(0.5)
        
        print("Cleaning up GPIO...")
        self.servo.cleanup()
        
        print("Closing barcode scanner...")
        self.scanner.close()
        
        # Final status report
        final_status = self.power.check_battery_status()
        print(f"\nFinal Battery Status: {final_status['percentage']:.1f}% "
              f"({final_status['voltage']:.2f}V)")
